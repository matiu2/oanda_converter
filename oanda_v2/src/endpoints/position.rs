use crate :: client :: Client ; struct Position < 'a > { client : & 'a Client , } impl < 'a > Position < 'a > { # [doc = " The Account’s Positions are provided."] # [derive (Serialize , Deserialize)] struct Code200 { # [doc = " The list of Account Positions."] positions : Vec < Position > , # [doc = " The ID of the most recent Transaction created for the"] # [doc = " Account"] last_transaction_id : Option < TransactionID > , } pub enum Positions_responsepositionsResponse { } # [doc = " List all Positions for an Account. The Positions returned"] # [doc = " are for every instrument that has had a position during the"] # [doc = " lifetime of an the Account."] pub async fn positions (& self , authorization : String , account_id : AccountId) -> Result < () > { let url = "/v3/accounts/{accountID}/positions" ; let url = url . replace ("{" + "accountID" + "}") ; let url = self . client . url (url) ; let query = [] ; let response = self . client . get (url) . header ("Authorization" , authorization) . query (& query) . send () . await ? ; let status_code = response . status_code () ; } # [doc = " The Account’s open Positions are provided."] # [derive (Serialize , Deserialize)] struct Code200 { # [doc = " The list of open Positions in the Account."] positions : Vec < Position > , # [doc = " The ID of the most recent Transaction created for the"] # [doc = " Account"] last_transaction_id : Option < TransactionID > , } pub enum OpenPositions_responseopen_positionsResponse { } # [doc = " List all open Positions for an Account. An open Position is"] # [doc = " a Position in an Account that currently has a Trade opened"] # [doc = " for it."] pub async fn open_positions (& self , authorization : String , account_id : AccountId) -> Result < () > { let url = "/v3/accounts/{accountID}/openPositions" ; let url = url . replace ("{" + "accountID" + "}") ; let url = self . client . url (url) ; let query = [] ; let response = self . client . get (url) . header ("Authorization" , authorization) . query (& query) . send () . await ? ; let status_code = response . status_code () ; } # [doc = " The Position is provided."] # [derive (Serialize , Deserialize)] struct Code200 { # [doc = " The requested Position."] position : Option < Position > , # [doc = " The ID of the most recent Transaction created for the"] # [doc = " Account"] last_transaction_id : Option < TransactionID > , } pub enum Get_responsegetResponse { } # [doc = " Get the details of a single Instrument’s Position in an"] # [doc = " Account. The Position may by open or not."] pub async fn get (& self , authorization : String , account_id : AccountId , instrument : InstrumentName) -> Result < () > { let url = "/v3/accounts/{accountID}/positions/{instrument}" ; let url = url . replace ("{" + "accountID" + "}") ; let url = url . replace ("{" + "instrument" + "}") ; let url = self . client . url (url) ; let query = [] ; let response = self . client . get (url) . header ("Authorization" , authorization) . query (& query) . send () . await ? ; let status_code = response . status_code () ; } # [doc = " The Position closeout request has been successfully"] # [doc = " processed."] # [derive (Serialize , Deserialize)] struct Code200 { # [doc = " The MarketOrderTransaction created to close the long"] # [doc = " Position."] long_order_create_transaction : Option < MarketOrderTransaction > , # [doc = " OrderFill Transaction that closes the long Position"] long_order_fill_transaction : Option < OrderFillTransaction > , # [doc = " OrderCancel Transaction that cancels the MarketOrder created"] # [doc = " to close the long Position"] long_order_cancel_transaction : Option < OrderCancelTransaction > , # [doc = " The MarketOrderTransaction created to close the short"] # [doc = " Position."] short_order_create_transaction : Option < MarketOrderTransaction > , # [doc = " OrderFill Transaction that closes the short Position"] short_order_fill_transaction : Option < OrderFillTransaction > , # [doc = " OrderCancel Transaction that cancels the MarketOrder created"] # [doc = " to close the short Position"] short_order_cancel_transaction : Option < OrderCancelTransaction > , # [doc = " The IDs of all Transactions that were created while"] # [doc = " satisfying the request."] related_transaction_i_ds : Vec < TransactionID > , # [doc = " The ID of the most recent Transaction created for the"] # [doc = " Account"] last_transaction_id : Option < TransactionID > , } pub enum Close_responsecloseResponse { E400 : # , E404 : [doc = " The Parameters provided that describe the Position closeout"] } # [doc = " Closeout the open Position for a specific instrument in"] # [doc = " an Account."] pub async fn close (& self , authorization : String , accept_datetime_format : AcceptDatetimeFormat , account_id : AccountId , instrument : InstrumentName) -> Result < () > { let url = "/v3/accounts/{accountID}/positions/{instrument}/close" ; let url = url . replace ("{" + "accountID" + "}") ; let url = url . replace ("{" + "instrument" + "}") ; let url = self . client . url (url) ; let query = [] ; let response = self . client . put (url) . header ("Authorization" , authorization) . header ("Accept-Datetime-Format" , accept_datetime_format) . query (& query) . send () . await ? ; let status_code = response . status_code () ; } }